<!DOCTYPE html>
<html>
  <head>
    <title>Screenshot maker</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
		<script src="../lib/jpg.js" ></script>
		<script src="../lib/tools.js" ></script>
		<link href="page.css" rel="stylesheet" />
  </head>
  <body>
		<div  id="drop_zone" class="imagediv">
			Drag an image here (local image or a test image), to parse the binary.
			<br>
			<span style="display:inline-block;">
				<img id="image1" src="../test_images/test_noexif.jpg" style="max-height:120px" /><br>
				NO EXIF
			</span>
			<span style="display:inline-block;">
				<img id="image2" src="../test_images/test_baseexif.jpg" style="max-height:120px" /><br>
				BASE EXIF
			</span>
			<span style="display:inline-block;">
				<img id="image3" src="../test_images/test_advanced.jpg" style="max-height:120px" /><br>
				EXTENDED EXIF
			</span>
			<span style="display:inline-block;">
				<img id="image4" src="../test_images/test_full.jpg" style="max-height:120px" /><br>
				FULL EXIF
			</span>
			<div id="bin_zone" class="bindiv">
				
			</div>
		</div>
		<div  id="info_zone" class="infodiv">
			<img src="../images/exif_binary.png" style="height:10vh;margin:0 auto;" />
			<h2>Instructions:</h2>
			<p>
				Get an image from your PC and drag it over the left frame. Or get an test image from the top of the page and drag it on that frame.
			</p>
			<p>
				You will get the original file binary on the left and the new generated (from this library) binary on the right side.<br>
				On the right frame, you will see a human formatted list of attributes of this JPG. Just move the mouse over every attribute to see
				where the attibute is located in the file.
			</p>
			<p>
				This tool is good if you are creating a JPEG by yourself and want to check if it is wrote like expected.
			</p>
			<p>
				Note: This is just a test. Many tags are still missing! Just use it as it is. Press F12, to open the console, if you want to see more info about your JPG!
			</p>
			<p>
				Tipp: Press the right button on an image to parse the exif section and get a list directly on this page!
			</p>
		</div>
		<img id="image0" src="" style="max-height:60px;position:fixed;top:5px;right:50px;box-shadow:5px 5px 5px #000;" />

		<a style="width:64px;height:64px;cursor:pointer;position:fixed;left:5px;top:5px;" href="../">üè†<br><small>Back to HOME</small></a>
		
		<script>
			let jpeg = null;
			const dp = document.getElementById("drop_zone");
			const ip = document.getElementById("info_zone");
			const bp = document.getElementById("bin_zone");
			let jMax = 0;
			
		</script>
		
		<script>
			dp.addEventListener("drop", dropHandler);
			dp.addEventListener("dragover", (event) => {
				console.log("File(s) in drop zone");
				dp.style.borderColor = "green";
				dp.style.backgroundColor = "gray";
				// Prevent default behavior (Prevent file from being opened)
				event.preventDefault();
			});
			dp.addEventListener("dragleave", (event) => { 
				dp.style.borderColor = "blue";
				dp.style.backgroundColor = "white";
			});
			
			function dropHandler(ev) 
			{
				console.log("File(s) dropped");
				
				dp.style.borderColor = "blue";
				dp.style.backgroundColor = "white";

				// Prevent default behavior (Prevent file from being opened)
				ev.preventDefault();

				let fileParsed = false;

				if (ev.dataTransfer.items) {
					// Use DataTransferItemList interface to access the file(s)
					[...ev.dataTransfer.items].forEach(async (item, i) => {
						// If dropped items aren't files, reject them
						if (!fileParsed && (item.kind === "file" || item.type=="text/uri-list")) {
							fileParsed = true;
							let file = item.getAsFile();
							console.log(file);
							if(!file) // probably a Firefox bug
							{
								let imgUrl = ev.dataTransfer.getData("text/uri-list") || extractImgSrcFromHTML(e.dataTransfer.getData("text/html")).match(/<img[^>]+src="([^"]+)"/)[1];
								file = await fetch(imgUrl);
								const blob = await file.blob();
								file = new File([blob], "image.jpg", { type: blob.type });
							}
							if(!file.type.startsWith("image"))
							{
								alert("File need to be an image");
							}
							else
							{
								jpeg = new JPG(file);
								
								jpeg.open().then(()=>{
									bp.innerHTML = "";

									//jpeg.setExif(JPGCONST.EXIF.DATETIME, "2030:02:01 01:02:03\0");

									let buff = jpeg.getBuffer(true);
									let arrBuff = new Uint8Array(buff);

									let div1 = _CN("div", {style:"position:absolute;top:20px;left:00px;width:600px;"}, [], bp);
									let div2 = _CN("div", {style:"position:absolute;top:20px;left:600px;width:600px;"}, [], bp);
									fillSPAN(0, jpeg.getBinary(), false, div1);
									setTimeout(()=>{fillSPAN(0, arrBuff, true, div2);}, 500); // wait, as the field must check the linked field

									console.log( jpeg );
									console.log( buff );

									ip.innerHTML = "";
									_CN("h2", {}, ["File blocks:"], ip);
									ip.appendChild(document.createElement("hr"));

									addBlock(ip, jpeg, 0);

									let blob = new Blob([arrBuff]);
									const dataURL = URL.createObjectURL(blob);

									document.getElementById("image0").src = dataURL;
								});
							}
						}
					});
				} 
			}
			
			async function fillSPAN(j, arrBuff, linked, div)
			{
				if(j==0)
				{
					if(!linked)
					{
						_CN("b", {style:"margin-left:20px;"}, ["Original FILE:"], div);
					}
					else
					{
						_CN("b", {style:"margin-left:20px;"}, ["NEW generated file:"], div);
					}
				}
					
				const maxJ = jpeg.subsections[1].offset + 100 - (jpeg.subsections[1].offset + 100) % 64 - 5;
				const upTo = Math.min(j + 256, maxJ);
				for(;j<upTo;j++)
				{
					if((j % 32) === 0) 
					{
						_CN("br", {}, [], div);
						_CN("b", {}, ["0x" + j.toString(16).padStart(4, '0')], div);
					}
					else if((j % 8) === 0)
					{
						_CN("i", {}, [" "], div);
					}
					let s = _CN("span", {}, [arrBuff[j].toString(16).padStart(2, '0')], div);
					if(linked)
					{
						const j2 = j+0;
						const sps = bp.getElementsByTagName("span");
						s.addEventListener("mouseenter", ()=>{
							sps[j2].style.backgroundColor = "#88f";
						});
						s.addEventListener("mouseleave", ()=>{
							sps[j2].style.backgroundColor = "";
						});
						if(sps[j2].textContent !== s.textContent)
						{
							s.classList.add("diffs");
						}
					}
				}
				if(upTo != maxJ)
				{
					setTimeout(()=>{fillSPAN(upTo, arrBuff, linked, div);}, 20);
				}
				else
				{
					if(!linked) jMax = j;
					_CN("span", {}, ["..."], div);
					
					_CN("br", {}, [], div);_CN("br", {}, [], div);
					_CN("b", {style:"margin-left:20px;"}, ["JPEG Image Data..."], div);
				}
			}
			
			const levelColor = ["#fff", "#ff0", "#fa0", "#f4a", "#a4f", "#06f", "#0ff"];
			
			function addBlock(parent, section, level)
			{
				const ul = _CN("ul", {}, [], parent);
				const li = _CN("li", {}, [section.name.toUpperCase()], ul);
				
				const sps = bp.getElementsByTagName("div")[0].getElementsByTagName("span");
				const sps2 = bp.getElementsByTagName("div")[1]?.getElementsByTagName("span");
				
				li.addEventListener("click", (e)=>{
					e.stopPropagation();
					console.log(section);
				});
				
				li.addEventListener("mouseenter", ()=>{
					li.style.background = levelColor[level];
					for(let j=section.offset;j<section.offset + section.getSize();j++)
					{
						if(j >= jMax) break;
						sps[j].style.background = levelColor[level];
						if(sps2) sps2[j].style.background = levelColor[level];
					}
				});
				
				li.addEventListener("mouseleave", ()=>{
					li.style.background = "";
					for(let j=section.offset;j<section.offset + section.getSize();j++)
					{
						if(j >= jMax) break;
						if(level > 0)
						{
							sps[j].style.background = levelColor[level-1];
							if(sps2) sps2[j].style.background = levelColor[level-1];
						}
						else 
						{
							sps[j].style.background = "";
							if(sps2) sps2[j].style.background = "";
						}
						
					}
				});
				
				let attrOffset = section.offset + 0;
				const ula = _CN("ul", {class:"attr"}, [], li);
				
				Object.keys(section.attributes).forEach(ak=>{
					let attrString = "";
					if(ak === "tag") attrString = "0x"+section.getAttribute(ak).toString(16);
					else attrString = section.getAttribute(ak);
					if(Array.isArray(attrString)) 
					{
						if(attrString.length == 0) attrString = "[]";
						else attrString = attrString.join(",");
					}
					if(!attrString && !Number.isInteger(attrString) && attrString !== "") console.error("invalid attribute");
					const lia = _CN("li", {}, [_CN("b",null,[ak + ": "]), _CN("i",null,[attrString])], ula);
					const baseOffset =  attrOffset;
					const dataOffset = (section.Type && [2,7,5,10].indexOf(section.Type) >= 0 ? jpeg.getRationalBaseOffset(0)+section.getAttribute("offset") : -1);
					let dataLen = 0;
					if(dataOffset > 0)
					{
						if(section.isRational())
						{
							if(!section.isRationalString()) dataLen = 8;
							else dataLen = section.Length;
						}
					}
					lia.addEventListener("mouseenter", ()=>{
						lia.style.background = "springgreen";
						for(let j=baseOffset;j<baseOffset+section.attributes[ak].size;j++)
						{
							sps[j].style.background = "springgreen";
						}
						if(dataOffset >= jMax) return;
						if(dataOffset > 0) setParseTag(sps[dataOffset], section);
						else setParseTag(sps[baseOffset], section);
						
						for(let j=dataOffset;j<dataOffset+dataLen;j++)
						{
							sps[j].style.background = "springgreen";
						}
					});

					lia.addEventListener("mouseleave", ()=>{
						lia.style.background = "";
						for(let j=baseOffset;j<baseOffset+section.attributes[ak].size;j++)
						{
							sps[j].style.background = levelColor[level];
						}
						if(dataOffset >= jMax) return;
						if(dataOffset > 0) setParseTag(sps[dataOffset], null);
						else setParseTag(sps[baseOffset], null);
						for(let j=dataOffset;j<dataOffset+dataLen;j++)
						{
							sps[j].style.background = levelColor[level-1];
						}
					});
					attrOffset += section.attributes[ak].size;
				});
				
				
				const definedEntries = Object.entries(section.subsections).map(([index, value]) => ({
					index: Number(index),
					value
				}));
				
				for(let j=0;j<definedEntries.length;j++)
				{
					addBlock(li, section.subsections[definedEntries[j].index], level + 1);
				}
			}
			
			const divParse = _CN("div", {class:"divParse"}, [], document.body);
			function setParseTag(el, section)
			{
				if(!section)
				{
					divParse.style.opacity = 0;
					return;
				}
				const r = el.getBoundingClientRect();
				divParse.style.left = parseInt(r.left) + "px";
				divParse.style.top = (parseInt(r.top) + 20) + "px";
				divParse.style.opacity = 1;
				
				divParse.innerHTML = "";
				_CN("h3", null, [section.name], divParse);
				const table = _CN("table", {}, [], divParse);
				if(section.Type == 5 || section.Type == 10) // Rational
				{
					_CN("tr", null, [_CN("th",null,["Rational Data:"]), _CN("td",null, ["[" + section.RationalData[0] + ", " + section.RationalData[1] + "]"])], table);
				}
				else if(section.Type == 2) // ASCII
				{
					_CN("tr", null, [_CN("th",null,["ASCII:"]), _CN("td",null, ["[" + section.RationalData + "]"])], table);
				}
				else
				{
					if(section.DataOffset)
					{
						if(section.isRational())
							_CN("tr", null, [_CN("th",null,["Value:"]), _CN("td",null, [section.DataOffset + " (" + (section.TagOptions?section.TagOptions[section.DataOffset]:"?") + ")"])], table);
						else
							_CN("tr", null, [_CN("th",null,["Value:"]), _CN("td",null, [section.getAttribute("value") + " (Type:" + (section.TagOptions?section.TagOptions[section.getAttribute("value")]:section.getAttribute("type")) + ")"])], table);
					}
					else
					{
						_CN("tr", null, [_CN("th",null,["Attributes:"]), _CN("td",null, [ Object.keys(section.attributes).length ])], table);
						_CN("tr", null, [_CN("th",null,["Subsections:"]), _CN("td",null, [ section.subsections?.length ])], table);
						_CN("tr", null, [_CN("th",null,["Block size:"]), _CN("td",null, [ section.view.byteLength ])], table);
						
						if(section.getAttribute("tagsRaw"))
						{
							_CN("tr", null, [_CN("th",null,["Tags size:"]), _CN("td",null, [ (section.getAttribute("tagsRaw").length + 1) ])], table);
							_CN("tr", null, [_CN("th",null,["Rational size:"]), _CN("td",null, [ (section.getAttribute("dataRaw").length + 1) ])], table);
						}
					}

					_CN("tr", null, [_CN("th",null,["Block offset:"]), _CN("td",null, [ (section.offset) + " (0x" + section.offset.toString(16) + ")" ])], table);
				}
			}
			JpegTools.addContextToImages();
		</script>
  </body>
</html>
